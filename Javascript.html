<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script>
    // Use google.script.run for communicating with Apps Script backend
    let currentRecords = [];
    let personFilterOverride = null; // Used to filter by a single person, overriding other filters

    function initializeDOMElements() {
        $eventTableBody = $('#eventTable tbody');
        $loadingIndicator = $('#loadingIndicator');
        $messageBox = $('#messageBox');
        $noRecordsMessage = $('#noRecords');
        $timelineHeader = $('#timelineHeader');
        const requiredElements = [$eventTableBody, $loadingIndicator, $messageBox, $noRecordsMessage, $timelineHeader];
        const missingElements = requiredElements.filter($el => $el.length === 0);
        if (missingElements.length > 0) {
            console.error('Some DOM elements could not be found:', missingElements);
            return false;
        }
        return true;
    }

    function showLoading(message = 'Loading data...') {
        $loadingIndicator.text(message).show();
        $messageBox.hide();
    }
    function hideLoading() {
        $loadingIndicator.hide();
    }
    function showMessage(message, type) {
        $messageBox.text(message).removeClass('success error').addClass(type).show();
        hideLoading();
        setTimeout(() => { $messageBox.fadeOut(); }, 5000);
    }
    function formatDateForDisplay(date) {
        if (!date) return '';
        try {
            const dateObj = new Date(date);
            if (isNaN(dateObj.getTime())) return '';
            return dateObj.toLocaleDateString();
        } catch (e) { return ''; }
    }
    function formatDateForInput(date) {
        if (!date) return '';
        try {
            const dateObj = new Date(date);
            if (isNaN(dateObj.getTime())) return '';
            return dateObj.toISOString().split('T')[0];
        } catch (e) { return ''; }
    }
    function getDayOfYear(date) {
        const start = new Date(date.getFullYear(), 0, 0);
        const diff = date - start;
        const oneDay = 1000 * 60 * 60 * 24;
        return Math.floor(diff / oneDay);
    }
    function parseLocalDate(dateStr) {
        if (!dateStr) return null;
        const parts = dateStr.split('-');
        if (parts.length !== 3) return null;
        const year = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10) - 1;
        const day = parseInt(parts[2], 10);
        return new Date(year, month, day, 0, 0, 0, 0);
    }
    function updateHeaderDate(date) {
        const $headerDate = $('#headerDate');
        if (!$headerDate.length) return;

        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        let displayDate = date;
        if (!displayDate) {
            $headerDate.text(''); // Clear the date text if no date is provided
            return;
        }

        const month = months[displayDate.getMonth()];
        const day = displayDate.getDate();
        const year = displayDate.getFullYear();
        $headerDate.text(`as of ${month} ${day}, ${year}`);
    }
    function renderTable(records) {
        $eventTableBody.empty();
        const filterDateStr = $('#filterDate').val();
        const filterDate = filterDateStr ? parseLocalDate(filterDateStr) : null;
        const eventTypeFilter = $('#eventType').val();
        // Get min and max level from dropdowns
        const minLevel = parseInt($('#minLevel').val(), 10) || 1;
        const maxLevel = parseInt($('#maxLevel').val(), 10) || 15;
        let filteredRecords = records.filter(record => {
            const level = parseInt(record.level, 10);
            if (isNaN(level)) return false;
            const isInRange = level >= minLevel && level <= maxLevel;
            return isInRange;
        });

        // Apply event type filter if set
        if (eventTypeFilter) {
            filteredRecords = filteredRecords.filter(record => {
                return (record.event || '').trim() === eventTypeFilter;
            });
        }

        // Apply date filter if set
        if (filterDate) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            filteredRecords = filteredRecords.filter(record => {
                const begin = new Date(record.begin);
                let end = record.end ? new Date(record.end) : null;
                if (isNaN(begin.getTime())) {
                    return false;
                }

                // Treat blank end as today
                if (!end || isNaN(end.getTime())) {
                    end = new Date(today);
                }
                end.setHours(0, 0, 0, 0);

                // Flexible end date for future filter dates
                if (filterDate > today && end.getTime() === today.getTime()) {
                    end = new Date(filterDate);
                    end.setHours(0, 0, 0, 0);
                }

                const match = filterDate >= begin && filterDate <= end;

                return match;
            });
        }

        // Apply person filter if set
        if (personFilterOverride) {
            filteredRecords = filteredRecords.filter(record => record.person === personFilterOverride);
            $('#eventTable thead th:first').text('Person (filtered: ' + personFilterOverride + ')');

            // Hide min/max level controls, show age controls
            $('#minLevel, #minLevelLabel').hide();
            $('#maxLevel, #maxLevelLabel').hide();
            $('#ageYears, #ageYearsLabel').show();
            $('#ageMonths, #ageMonthsLabel').show();

            // Always set age fields based on alive record and current filter date (or today)
            const aliveRecord = records.find(r => r.person === personFilterOverride && (r.event || '').trim() === 'Alive');
            let ageYears = '', ageMonths = '';
            if (aliveRecord) {
                const begin = new Date(aliveRecord.begin);
                const filterDateStr = $('#filterDate').val();
                const filterDate = filterDateStr ? parseLocalDate(filterDateStr) : new Date();
                let years = filterDate.getFullYear() - begin.getFullYear();
                let months = filterDate.getMonth() - begin.getMonth();
                let days = filterDate.getDate() - begin.getDate();
                if (days < 0) months--;
                if (months < 0) { years--; months += 12; }
                if (years < 0) { years = 0; months = 0; }
                ageYears = years;
                ageMonths = months;
            }
            $('#ageYears').val(ageYears);
            $('#ageMonths').val(ageMonths);
        } else {
            $('#eventTable thead th:first').text('Person');
            // Show min/max level controls, hide age controls
            $('#minLevel, #minLevelLabel').show();
            $('#maxLevel, #maxLevelLabel').show();
            $('#ageYears, #ageYearsLabel').hide();
            $('#ageMonths, #ageMonthsLabel').hide();
        }

        // Sort filteredRecords based on sortBy dropdown
        const sortBy = $('#sortBy').val() || 'person';
        filteredRecords.sort((a, b) => {
            if (sortBy === 'person') {
                return (a.person || '').localeCompare(b.person || '');
            } else if (sortBy === 'begin') {
                const aDate = new Date(a.begin);
                const bDate = new Date(b.begin);
                return aDate - bDate;
            }
            return 0;
        });

        const $theadRow = $('#eventTable thead tr');
        $theadRow.empty();
        if (personFilterOverride) {
            $theadRow.append('<th class="person-filter-active">Person</th><th>Event</th><th>Begin Date</th><th>End Date</th><th>Notes</th>' + (filterDate ? '<th>Since</th>' : ''));
        } else {
            $theadRow.append('<th>Person</th><th>Event</th><th>Begin Date</th><th>End Date</th><th>Notes</th>' + (filterDate ? '<th>Since</th>' : ''));
        }
        if (filteredRecords.length === 0) {
            $noRecordsMessage.show();
            return;
        }
        $noRecordsMessage.hide();

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayDayOfYear = getDayOfYear(today);

        filteredRecords.forEach(record => {
            const $row = $('<tr>');
            const eventType = (record.event || '').trim();
            let notesText = record.notes || '';

            // --- FLEXIBLE END DATE LOGIC FOR DISPLAY ---
            const filterDateStr = $('#filterDate').val();
            const filterDate = filterDateStr ? parseLocalDate(filterDateStr) : null;
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const begin = new Date(record.begin);
            const end = record.end ? new Date(record.end) : null; // Original end date from record
            let endForDisplay = end; // This will be the date used for display and age calculation

            // If the original end date is blank (ongoing event), determine what to show.
            if (!end || isNaN(end.getTime())) {
                // If the filter date is set and is in the future, use it.
                if (filterDate && filterDate > today) {
                    endForDisplay = new Date(filterDate);
                } else {
                    // Otherwise, default to today.
                    endForDisplay = new Date(today);
                }
            }

            if (eventType === 'Alive') {
                // A real end date that is in the past means deceased.
                if (end && !isNaN(end.getTime()) && end < today) {
                    $row.addClass('deceased-row');
                } else {
                    $row.addClass('alive-row');
                }

                // Calculate age based on the potentially modified display end date.
                if (!isNaN(begin.getTime())) {
                    let years = endForDisplay.getFullYear() - begin.getFullYear();
                    let months = endForDisplay.getMonth() - begin.getMonth();
                    let days = endForDisplay.getDate() - begin.getDate();
                    if (days < 0) months--;
                    if (months < 0) { years--; months += 12; }
                    if (years < 0) { years = 0; months = 0; }
                    notesText = `${years} years and ${months} months old`;
                }
            } else if (eventType === 'Married') {
                $row.addClass('married-row');
            }

            // Create clickable person cell
            const $personCell = $('<td>')
                .addClass('clickable-person')
                .css('cursor', 'pointer')
                .text(record.person || '')
                .on('click', function(e) {
                    e.stopPropagation();
                    personFilterOverride = record.person;
                    renderTable(currentRecords);
                });

            // Create clickable date cells. Display the original end date from the record.
            const $beginDateCell = $('<td>').addClass('clickable-date').text(formatDateForDisplay(record.begin));
            const $endDateCell = $('<td>').addClass('clickable-date').text(formatDateForDisplay(endForDisplay));

            // Highlight for upcoming or current anniversaries/birthdays (always relative to today)
            const isTargetEvent = eventType === 'Alive' || eventType === 'Married';
            if (isTargetEvent) {
                const beginDate = new Date(record.begin);
                if (!isNaN(beginDate.getTime())) {
                    // Create an anniversary date in the *current* year to compare apples-to-apples
                    const anniversaryDate = new Date(beginDate);
                    anniversaryDate.setFullYear(today.getFullYear());

                    const anniversaryDayOfYear = getDayOfYear(anniversaryDate);
                    const daysInYear = new Date(today.getFullYear(), 1, 29).getDate() === 29 ? 366 : 365;
                    
                    let diff = anniversaryDayOfYear - todayDayOfYear;

                    // Adjust for year-end wrap-around. E.g. if today is Dec 31 and anniversary is Jan 1.
                    if (diff > daysInYear / 2) {
                        diff -= daysInYear;
                    } else if (diff < -daysInYear / 2) {
                        diff += daysInYear;
                    }

                    if (diff === 0) {
                        $beginDateCell.addClass('highlight-today'); // On the day: Neon Orange
                    } else if (diff > 0 && diff <= 14) {
                        $beginDateCell.addClass('highlight-upcoming'); // Upcoming within 2 weeks: Neon Green
                    } else if (diff < 0 && diff >= -14) {
                        $beginDateCell.addClass('highlight-recent'); // Recent within last 2 weeks: Neon Yellow
                    }
                }
            }

            if (record.begin) {
                $beginDateCell.on('click', function(e) {
                    e.stopPropagation();
                    const newDate = formatDateForInput(record.begin);
                    $('#filterDate').val(newDate).trigger('change');
                });
            }
            // Make the displayed end date clickable, even if it's dynamically generated.
            if (endForDisplay) {
                $endDateCell.on('click', function(e) {
                    e.stopPropagation();
                    const newDate = formatDateForInput(endForDisplay);
                    $('#filterDate').val(newDate).trigger('change');
                });
            }

            $row.append(
                $personCell,
                $('<td>').text(record.event || ''),
                $beginDateCell,
                $endDateCell,
                $('<td>').text(notesText)
            );
            if (filterDate) {
                let sinceText = '';
                if (!isNaN(begin.getTime())) {
                    const diff = diffYearsMonths(begin, filterDate);
                    if (diff) sinceText = diff;
                }
                $row.append($('<td>').text(sinceText));
            }
            $eventTableBody.append($row);
        });
        hideLoading();
    }
    function diffYearsMonths(start, end) {
        if (!(start instanceof Date) || !(end instanceof Date)) return '';
        if (isNaN(start.getTime()) || isNaN(end.getTime())) return '';
        let years = end.getFullYear() - start.getFullYear();
        let months = end.getMonth() - start.getMonth();
        let days = end.getDate() - start.getDate();
        if (days < 0) months--;
        if (months < 0) { years--; months += 12; }
        if (years < 0) return '';
        let result = '';
        if (years > 0) result += years + 'y';
        if (months > 0) result += (result ? ' ' : '') + months + 'm';
        if (!result) result = '0m';
        return result;
    }
    function saveFiltersToLocalStorage() {
        localStorage.setItem('timelineFilters', JSON.stringify({
            minLevel: $('#minLevel').val(),
            maxLevel: $('#maxLevel').val(),
            filterDate: $('#filterDate').val(),
            eventType: $('#eventType').val(),
            sortBy: $('#sortBy').val()
        }));
    }
    function restoreFiltersFromLocalStorage() {
        const filters = JSON.parse(localStorage.getItem('timelineFilters') || '{}');
        if (filters.minLevel) $('#minLevel').val(filters.minLevel);
        if (filters.maxLevel) $('#maxLevel').val(filters.maxLevel);
        if (filters.filterDate) {
            $('#filterDate').val(filters.filterDate);
        } else {
            $('#filterDate').val('');
        }
        if (filters.eventType) $('#eventType').val(filters.eventType);
        if (filters.sortBy) $('#sortBy').val(filters.sortBy);
    }
    function populateLevelDropdowns() {
        const $minLevel = $('#minLevel');
        const $maxLevel = $('#maxLevel');
        $minLevel.empty();
        $maxLevel.empty();
        
        // Get level labels from localStorage or fetch from server
        const levelLabels = JSON.parse(localStorage.getItem('levelLabels') || '[]');

        // Determine the maximum level dynamically, ensuring at least 15 levels are shown as a fallback.
        const maxLevelFromData = levelLabels.length > 0 
            ? Math.max(...levelLabels.map(l => parseInt(l.level, 10)).filter(Number.isFinite)) 
            : 0;
        const maxLevelToShow = Math.max(15, maxLevelFromData);
        
        for (let i = 1; i <= maxLevelToShow; i++) {
            const label = levelLabels.find(l => l.level == i);
            const displayText = label ? `${i} - ${label.label}` : i.toString();
            $minLevel.append($('<option>').val(i).text(displayText));
            $maxLevel.append($('<option>').val(i).text(displayText));
        }
    }

    function updateMaxLevelOptions(minLevel) {
        const $maxLevel = $('#maxLevel');
        // Ensure minLevel is a number
        const numericMinLevel = parseInt(minLevel, 10);
        if (isNaN(numericMinLevel)) return;

        $maxLevel.find('option').each(function() {
            const optionValue = parseInt($(this).val(), 10);
            // Disable options with a value less than the minimum level
            $(this).prop('disabled', optionValue < numericMinLevel);
        });
    }

    function fetchAndUpdateLevelLabels() {
        // Fetches the latest level labels from the server and stores them
        // in localStorage for the *next* page load. Does not update the UI.
        google.script.run
            .withSuccessHandler(labels => {
                localStorage.setItem('levelLabels', JSON.stringify(labels));
            })
            .withFailureHandler(error => {
                // This is a background task, so we just log the error.
                // The app will continue to function with the currently stored labels.
                console.warn('Failed to fetch and update level labels:', error);
            })
            .getLevelLabels();
    }
    function populateEventTypeDropdown(records) {
        const $eventType = $('#eventType');
        const selectedValue = $eventType.val(); // Store the currently selected value

        const eventTypes = new Set();
        records.forEach(record => {
            if (record.event && record.event.trim()) {
                eventTypes.add(record.event.trim());
            }
        });

        // Clear existing options except "All Events"
        $eventType.find('option:not(:first)').remove();

        // Add event types sorted alphabetically
        Array.from(eventTypes).sort().forEach(eventType => {
            $eventType.append($('<option>').val(eventType).text(eventType));
        });

        // Restore the previously selected value
        $eventType.val(selectedValue);
    }
    $(document).on('change', '#minLevel, #maxLevel, #eventType, #sortBy', function() {
        // When Min Level changes, update Max Level options and value
        if ($(this).is('#minLevel')) {
            const minLevel = $(this).val();
            const $maxLevel = $('#maxLevel');
            updateMaxLevelOptions(minLevel);
            $maxLevel.val(minLevel);
        }
        saveFiltersToLocalStorage();
        renderTable(currentRecords);
    });

    // Update the change handler for minLevel and maxLevel to clear person filter if active
    $(document).on('change', '#minLevel, #maxLevel', function() {
        if (personFilterOverride) {
            personFilterOverride = null;
        }
        renderTable(currentRecords);
        saveFiltersToLocalStorage();
    });

    // Keep the existing handler for other filters
    $(document).on('change', '#eventType, #sortBy', function() {
        renderTable(currentRecords);
        saveFiltersToLocalStorage();
    });

    function setupApplication(records) {
        currentRecords = records;

        // 1. Populate all dynamic dropdowns based on the data.
        populateEventTypeDropdown(records);

        // 2. Restore all filters now that dropdowns have their options.
        restoreFiltersFromLocalStorage();
        // After restoring, ensure the max level options are correctly constrained.
        updateMaxLevelOptions($('#minLevel').val());
        if (!$('#sortBy').val()) $('#sortBy').val('begin');

        // 3. Render the table with the restored filters applied.
        renderTable(records);
        hideLoading();
    }

    $(document).on('click', '#clearFilters', function() {
        const $minLevel = $('#minLevel');
        const $maxLevel = $('#maxLevel');
        const $filterDate = $('#filterDate');
        const $eventType = $('#eventType');
        const $sortBy = $('#sortBy');

        // Store current min/max level values before clearing
        const prevMinLevel = localStorage.getItem('timelinePrevMinLevel') || $minLevel.val() || '1';
        const prevMaxLevel = localStorage.getItem('timelinePrevMaxLevel') || $maxLevel.val() || '15';

        // If person filter is on, clear only the person filter and restore min/max levels, but do NOT reset filter date or event type
        if (personFilterOverride) {
            personFilterOverride = null;

            // Restore min/max level controls and their values
            $('#minLevel, #minLevelLabel').show();
            $('#maxLevel, #maxLevelLabel').show();
            $('#ageYears, #ageYearsLabel').hide();
            $('#ageMonths, #ageMonthsLabel').hide();

            $minLevel.val(prevMinLevel);
            $maxLevel.val(prevMaxLevel);
            updateMaxLevelOptions(prevMinLevel);

            // Do NOT reset filterDate or eventType
            saveFiltersToLocalStorage();
            renderTable(currentRecords);
            return;
        }

        // Otherwise, clear all filters as usual
        $minLevel.val('1');
        $maxLevel.val('15');
        updateMaxLevelOptions(1);
        $('#filterDate').val('');
        $eventType.val('');
        $sortBy.val('begin');
        personFilterOverride = null;
        saveFiltersToLocalStorage();
        renderTable(currentRecords);
        updateHeaderDate(null); // Clear header date
    });
    

    // Store min/max level values whenever they change
    $(document).on('change', '#minLevel, #maxLevel', function() {
        localStorage.setItem('timelinePrevMinLevel', $('#minLevel').val());
        localStorage.setItem('timelinePrevMaxLevel', $('#maxLevel').val());
        if (personFilterOverride) {
            personFilterOverride = null;
        }
        renderTable(currentRecords);
        saveFiltersToLocalStorage();
    });

    function fetchAndUpdateRecords(isInitialLoad = false) {
        // On first load, show the loading indicator. On subsequent loads, this runs silently in the background.
        if (isInitialLoad) {
            showLoading('Loading data for the first time...');
        }

        google.script.run
            .withSuccessHandler(records => {
                // Store the original, unmodified records.
                currentRecords = records;

                // Always update the local storage cache for the next visit.
                localStorage.setItem('timelineRecords', JSON.stringify(records));

                // If this is the first time loading the data, we need to render the table.
                if (isInitialLoad) {
                    // On first load, we need to run the full setup.
                    setupApplication(records);
                }
            })
            .withFailureHandler(error => {
                showMessage('Error fetching data: ' + error.message, 'error');
                // Ensure loading indicator is hidden on failure too.
                if (isInitialLoad) {
                    hideLoading();
                }
            })
            .getData();
    }
    $(document).ready(function() {
        if (initializeDOMElements()) {
            // 1. Populate static dropdowns that don't depend on data.
            populateLevelDropdowns();

            // 2. Try to load main data from cache for an instant UI.
            const cachedRecords = JSON.parse(localStorage.getItem('timelineRecords') || 'null');
            if (cachedRecords) {
                setupApplication(cachedRecords);
                fetchAndUpdateRecords(false); // Fetch updates in the background.
            } else {
                console.log('No cached records found. Performing initial fetch.');
                fetchAndUpdateRecords(true); // Fetch for the first time, render, and cache.
            }

            // 3. In the background, fetch the latest level labels to update the cache.
            fetchAndUpdateLevelLabels();

            // Set initial header date
            updateHeaderDate(parseLocalDate($('#filterDate').val()));
        } else {
            console.error('Failed to initialize DOM elements');
            showMessage('Failed to initialize the application. Please refresh the page.', 'error');
        }
    });

    $(document).on('change', '#minLevel, #maxLevel', function() {
        if (personFilterOverride) {
            personFilterOverride = null;
        }
        renderTable(currentRecords);
        saveFiltersToLocalStorage();
    });

    $(document).on('change', '#filterDate', function() {
        saveFiltersToLocalStorage();
        updateHeaderDate(parseLocalDate($('#filterDate').val()));

        if (personFilterOverride) {
            // Always recalculate age fields based on alive record and new filter date
            const aliveRecord = currentRecords.find(r => r.person === personFilterOverride && (r.event || '').trim() === 'Alive');
            if (aliveRecord) {
                const begin = new Date(aliveRecord.begin);
                const filterDateStr = $('#filterDate').val();
                const filterDate = filterDateStr ? parseLocalDate(filterDateStr) : new Date();
                let years = filterDate.getFullYear() - begin.getFullYear();
                let months = filterDate.getMonth() - begin.getMonth();
                let days = filterDate.getDate() - begin.getDate();
                if (days < 0) months--;
                if (months < 0) { years--; months += 12; }
                if (years < 0) { years = 0; months = 0; }
                $('#ageYears').val(years);
                $('#ageMonths').val(months);
            } else {
                // If no alive record, clear the age fields
                $('#ageYears').val('');
                $('#ageMonths').val('');
            }
        }

        renderTable(currentRecords);
    });

    // When age filters change, update filterDate based on alive record
    $(document).on('change', '#ageYears, #ageMonths', function() {
        if (personFilterOverride) {
            const aliveRecord = currentRecords.find(r => r.person === personFilterOverride && (r.event || '').trim() === 'Alive');
            if (aliveRecord) {
                const begin = new Date(aliveRecord.begin);
                let years = parseInt($('#ageYears').val(), 10) || 0;
                let months = parseInt($('#ageMonths').val(), 10) || 0;
                let newDate = new Date(begin.getFullYear(), begin.getMonth() + months, begin.getDate(), 0, 0, 0, 0);
                newDate.setFullYear(begin.getFullYear() + years);
                $('#filterDate').val(formatDateForInput(newDate));
                saveFiltersToLocalStorage();
                renderTable(currentRecords);
                updateHeaderDate(newDate);
            }
        }
    });

    // When filterDate changes, update age filters based on alive record
    $(document).on('change', '#filterDate', function() {
        if (personFilterOverride && $('#ageYears').length) {
            const aliveRecord = currentRecords.find(r => r.person === personFilterOverride && (r.event || '').trim() === 'Alive');
            if (aliveRecord) {
                const begin = new Date(aliveRecord.begin);
                const filterDateStr = $('#filterDate').val();
                const filterDate = filterDateStr ? parseLocalDate(filterDateStr) : new Date();
                let years = filterDate.getFullYear() - begin.getFullYear();
                let months = filterDate.getMonth() - begin.getMonth();
                let days = filterDate.getDate() - begin.getDate();
                if (days < 0) months--;
                if (months < 0) { years--; months += 12; }
                if (years < 0) { years = 0; months = 0; }
                $('#ageYears').val(years);
                $('#ageMonths').val(months);
            }
        }
    });
</script>


